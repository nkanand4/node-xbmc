// Generated by CoffeeScript 1.4.0
(function() {
  var Connection, defer, net, pubsub,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  pubsub = require('./PubSub');

  defer = require('node-promise').defer;

  net = require('net');

  Connection = (function() {

    function Connection(options) {
      var _base, _base1, _base2, _base3, _base4, _base5, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      this.options = options != null ? options : {};
      this.onMessage = __bind(this.onMessage, this);

      this.parseBuffer = __bind(this.parseBuffer, this);

      this.onClose = __bind(this.onClose, this);

      this.onError = __bind(this.onError, this);

      this.onOpen = __bind(this.onOpen, this);

      this.publish = __bind(this.publish, this);

      this.close = __bind(this.close, this);

      this.send = __bind(this.send, this);

      this.isActive = __bind(this.isActive, this);

      this.create = __bind(this.create, this);

      if ((_ref = (_base = this.options).port) == null) {
        _base.port = 9090;
      }
      if ((_ref1 = (_base1 = this.options).host) == null) {
        _base1.host = '127.0.0.1';
      }
      if ((_ref2 = (_base2 = this.options).user) == null) {
        _base2.user = 'xbmc';
      }
      if ((_ref3 = (_base3 = this.options).password) == null) {
        _base3.password = false;
      }
      if ((_ref4 = (_base4 = this.options).verbose) == null) {
        _base4.verbose = false;
      }
      if ((_ref5 = (_base5 = this.options).connectNow) == null) {
        _base5.connectNow = true;
      }
      this.readRaw = '';
      this.sendQueue = [];
      this.deferreds = {};
      if (this.options.connectNow) {
        this.create();
      }
    }

    Connection.prototype.create = function() {
      this.socket = net.connect({
        host: this.options.host,
        port: this.options.port
      });
      this.socket.on('connect', this.onOpen);
      this.socket.on('data', this.onMessage);
      this.socket.on('error', this.onError);
      this.socket.on('disconnect', this.onClose);
      return this.socket.on('close', this.onClose);
    };

    Connection._id = 0;

    Connection.generateId = function() {
      return "__id" + (++Connection._id);
    };

    Connection.prototype.isActive = function() {
      var _ref;
      return ((_ref = this.socket) != null ? _ref._connecting : void 0) === false;
    };

    Connection.prototype.send = function(data) {
      var dfd, _base, _name, _ref, _ref1;
      if (data == null) {
        data = null;
      }
      if (!data) {
        throw new Error('Connection: Unknown arguments');
      }
      if ((_ref = data.id) == null) {
        data.id = Connection.generateId();
      }
      dfd = (_ref1 = (_base = this.deferreds)[_name = data.id]) != null ? _ref1 : _base[_name] = defer();
      if (!this.isActive()) {
        this.sendQueue.push(data);
      } else {
        data.jsonrpc = '2.0';
        data = JSON.stringify(data);
        this.publish('send', data);
        this.socket.write(data);
      }
      return dfd.promise;
    };

    Connection.prototype.close = function(fn) {
      if (fn == null) {
        fn = null;
      }
      try {
        this.socket.end();
        this.socket.destroy();
        if (fn) {
          return fn();
        }
      } catch (err) {
        this.publish('error', err);
        if (fn) {
          return fn(err);
        }
      }
    };

    Connection.prototype.publish = function(topic, data) {
      var dataVerbose;
      if (data == null) {
        data = {};
      }
      if (this.options.verbose) {
        dataVerbose = typeof data === 'object' ? JSON.stringify(data) : data;
        if (this.options.verbose) {
          console.log("[connection:" + topic + "]", dataVerbose);
        }
      }
      return pubsub.emit("connection:" + topic, data);
    };

    Connection.prototype.onOpen = function() {
      var _this = this;
      this.publish('open');
      return setTimeout((function() {
        var item, _i, _len, _ref;
        _ref = _this.sendQueue;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _this.send(item);
        }
        return _this.sendQueue = [];
      }), 500);
    };

    Connection.prototype.onError = function(evt) {
      return this.publish('error', evt);
    };

    Connection.prototype.onClose = function(evt) {
      return this.publish('close', evt);
    };

    Connection.prototype.parseBuffer = function(buffer) {
      var line, lines, rawline, rawlines, splitStr, str, _i, _len;
      this.readRaw = buffer.toString();
      lines = [];
      try {
        this.readRaw = this.readRaw.replace(/}{/g, '}%%%%{');
        this.readRaw.split(/%%%%/).forEach(function(resp) {
                line = JSON.parse(resp);
                lines.push(line);
        });
        this.readRaw = '';
      } catch (err) {
        splitStr = '{"jsonrpc":"2.0"';
        rawlines = this.readRaw.split(splitStr);
        lines = [];
        for (_i = 0, _len = rawlines.length; _i < _len; _i++) {
          rawline = rawlines[_i];
          if (!rawline.length) {
            continue;
          }
          str = splitStr + rawline;
          try {
            line = JSON.parse(str);
            lines.push(line);
            this.readRaw = '';
          } catch (_error) {}
        }
      }
      return lines;
    };

    Connection.prototype.onMessage = function(buffer) {
      var dfd, evt, id, line, lines, _i, _len, _ref, _ref1, _results;
      lines = this.parseBuffer(buffer);
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        evt = {};
        evt.data = line;
        id = (_ref = evt.data) != null ? _ref.id : void 0;
        dfd = this.deferreds[id];
        delete this.deferreds[id];
        if (evt.data.error) {
          this.onError(evt);
          if (dfd) {
            dfd.reject(evt.data);
          }
          continue;
        }
        this.publish('data', evt.data);
        if ((_ref1 = evt.data.method) != null ? _ref1.indexOf('.On' > 1) : void 0) {
          this.publish('notification', evt.data);
        }
        if (dfd) {
          _results.push(dfd.resolve(evt.data));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Connection;

  })();

  module.exports = Connection;

}).call(this);
